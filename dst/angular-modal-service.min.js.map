{"version":3,"sources":["angular-modal-service.min.js","angular-modal-service.js"],"names":["module","angular","factory","$document","$compile","$controller","$http","$rootScope","$q","$templateCache","ModalService","self","this","getTemplate","template","templateUrl","deferred","defer","resolve","cachedTemplate","get","undefined","method","url","cache","then","result","put","data","error","reject","promise","modalLayers","showModal","options","controllerName","controller","controllerAs","modalScope","$new","closeDeferred","inputs","$scope","close","delay","window","setTimeout","modalObj","find","modal","splice","indexOf","$destroy","modalElement","remove","$applyAsync","inputName","modalElementTemplate","element","linkFn","$element","modalController","appendElement","append","body","scope","push"],"mappings":"AAAA;AACA,CCKC,WAEC,YAEA,IAAIA,GAASC,QAAQD,OAAO,yBAE5BA,GAAOE,QAAQ,gBAAiB,YAAa,WAAY,cAAe,QAAS,aAAc,KAAM,iBACnG,SAASC,EAAWC,EAAUC,EAAaC,EAAOC,EAAYC,EAAIC,GAKlE,QAASC,KAEP,GAAIC,GAAOC,KAKPC,EAAc,SAASC,EAAUC,GACnC,GAAIC,GAAWR,EAAGS,OAClB,IAAGH,EACDE,EAASE,QAAQJ,OACZ,IAAGC,EAAa,CAErB,GAAII,GAAiBV,EAAeW,IAAIL,EAClBM,UAAnBF,EACDH,EAASE,QAAQC,GAIjBb,GAAOgB,OAAQ,MAAOC,IAAKR,EAAaS,OAAO,IAC5CC,KAAK,SAASC,GAEbjB,EAAekB,IAAIZ,EAAaW,EAAOE,MACvCZ,EAASE,QAAQQ,EAAOE,OACvB,SAASC,GACVb,EAASc,OAAOD,SAItBb,GAASc,OAAO,iDAElB,OAAOd,GAASe,QAGlBpB,GAAKqB,eAELrB,EAAKsB,UAAY,SAASC,GAGxB,GAAIlB,GAAWR,EAAGS,QAGdkB,EAAiBD,EAAQE,UAC7B,OAAID,IAODD,EAAQG,eACTF,EAAiBA,EAAiB,OAASD,EAAQG,cAIrDxB,EAAYqB,EAAQpB,SAAUoB,EAAQnB,aACnCU,KAAK,SAASX,GAGb,GAAIwB,GAAa/B,EAAWgC,OAQxBC,EAAgBhC,EAAGS,QACnBwB,GACFC,OAAQJ,EACRK,MAAO,SAASjB,EAAQkB,IACTvB,SAAVuB,GAAiC,OAAVA,KAAgBA,EAAQ,GAClDC,OAAOC,WAAW,WAEhBN,EAActB,QAAQQ,EACtB,IAAIqB,GAAWpC,EAAKqB,YAAYgB,KAAK,SAAUD,GAC7C,MAAOA,GAASE,QAAUA,GAE5BtC,GAAKqB,YAAYkB,OAAOvC,EAAKqB,YAAYmB,QAAQJ,GAAW,GAG5DT,EAAWc,WACXC,EAAaC,SAKbb,EAAOE,MAAQ,KACf3B,EAAW,KACXwB,EAAgB,KAChBS,EAAQ,KACRR,EAAS,KACTY,EAAe,KACff,EAAa,KACb/B,EAAWgD,eACVX,IAKP,IAAGV,EAAQO,OACT,IAAI,GAAIe,KAAatB,GAAQO,OAC3BA,EAAOe,GAAatB,EAAQO,OAAOe,EAKvC,IAAIC,GAAuBxD,QAAQyD,QAAQ5C,GAIvC6C,EAASvD,EAASqD,GAClBJ,EAAeM,EAAOrB,EAC1BG,GAAOmB,SAAWP,CAGlB,IAAIQ,GAAkBxD,EAAY8B,EAAgBM,EAG9CP,GAAQ4B,cAEV5B,EAAQ4B,cAAcC,OAAOV,GAG7BW,EAAKD,OAAOV,EAId,IAAIJ,IACFb,WAAYyB,EACZI,MAAO3B,EACPoB,QAASL,EACTV,MAAOH,EAAcT,QAIvBpB,GAAKqB,YAAYkC,MACfjB,MAAOA,EACPN,MAAOF,EAAOE,QAEhB3B,EAASE,QAAQ+B,KAGlBxB,KAAK,KAAM,SAASI,GACnBb,EAASc,OAAOD,KAGbb,EAASe,UAvGdf,EAASc,OAAO,qCACTd,EAASe,UA/CtB,GAAIiC,GAAO7D,EAAU6C,KAAK,OA0J1B,OAAO,IAAItC","file":"angular-modal-service.min.js","sourcesContent":["/*angular-modal-service v0.6.7 - https://github.com/dwmkerr/angular-modal-service */\n!function(){\"use strict\";var e=angular.module(\"angularModalService\",[]);e.factory(\"ModalService\",[\"$document\",\"$compile\",\"$controller\",\"$http\",\"$rootScope\",\"$q\",\"$templateCache\",function(e,l,n,o,r,t,a){function c(){var e=this,c=function(e,l){var n=t.defer();if(e)n.resolve(e);else if(l){var r=a.get(l);void 0!==r?n.resolve(r):o({method:\"GET\",url:l,cache:!0}).then(function(e){a.put(l,e.data),n.resolve(e.data)},function(e){n.reject(e)})}else n.reject(\"No template or templateUrl has been specified.\");return n.promise};e.modalLayers=[],e.showModal=function(o){var a=t.defer(),i=o.controller;return i?(o.controllerAs&&(i=i+\" as \"+o.controllerAs),c(o.template,o.templateUrl).then(function(c){var u=r.$new(),d=t.defer(),p={$scope:u,close:function(l,n){(void 0===n||null===n)&&(n=0),window.setTimeout(function(){d.resolve(l);var n=e.modalLayers.find(function(e){return e.modal===y});e.modalLayers.splice(e.modalLayers.indexOf(n),1),u.$destroy(),h.remove(),p.close=null,a=null,d=null,y=null,p=null,h=null,u=null,r.$applyAsync()},n)}};if(o.inputs)for(var m in o.inputs)p[m]=o.inputs[m];var f=angular.element(c),v=l(f),h=v(u);p.$element=h;var $=n(i,p);o.appendElement?o.appendElement.append(h):s.append(h);var y={controller:$,scope:u,element:h,close:d.promise};e.modalLayers.push({modal:y,close:p.close}),a.resolve(y)}).then(null,function(e){a.reject(e)}),a.promise):(a.reject(\"No controller has been specified.\"),a.promise)}}var s=e.find(\"body\");return new c}])}();\n//# sourceMappingURL=angular-modal-service.min.js.map","//  angularModalService.js\n//\n//  Service for showing modal dialogs.\n\n/***** JSLint Config *****/\n/*global angular  */\n(function() {\n\n  'use strict';\n\n  var module = angular.module('angularModalService', []);\n\n  module.factory('ModalService', ['$document', '$compile', '$controller', '$http', '$rootScope', '$q', '$templateCache',\n    function($document, $compile, $controller, $http, $rootScope, $q, $templateCache) {\n\n    //  Get the body of the document, we'll add the modal to this.\n    var body = $document.find('body');\n\n    function ModalService() {\n\n      var self = this;\n\n      //  Returns a promise which gets the template, either\n      //  from the template parameter or via a request to the\n      //  template url parameter.\n      var getTemplate = function(template, templateUrl) {\n        var deferred = $q.defer();\n        if(template) {\n          deferred.resolve(template);\n        } else if(templateUrl) {\n          // check to see if the template has already been loaded\n          var cachedTemplate = $templateCache.get(templateUrl);\n          if(cachedTemplate !== undefined) {\n            deferred.resolve(cachedTemplate);\n          }\n          // if not, let's grab the template for the first time\n          else {\n            $http({method: 'GET', url: templateUrl, cache: true})\n              .then(function(result) {\n                // save template into the cache and return the template\n                $templateCache.put(templateUrl, result.data);\n                deferred.resolve(result.data);\n              }, function(error) {\n                deferred.reject(error);\n              });\n          }\n        } else {\n          deferred.reject(\"No template or templateUrl has been specified.\");\n        }\n        return deferred.promise;\n      };\n\n      self.modalLayers = [];\n\n      self.showModal = function(options) {\n\n        //  Create a deferred we'll resolve when the modal is ready.\n        var deferred = $q.defer();\n\n        //  Validate the input parameters.\n        var controllerName = options.controller;\n        if(!controllerName) {\n          deferred.reject(\"No controller has been specified.\");\n          return deferred.promise;\n        }\n\n        //  If a 'controllerAs' option has been provided, we change the controller\n        //  name to use 'as' syntax. $controller will automatically handle this.\n        if(options.controllerAs) {\n          controllerName = controllerName + \" as \" + options.controllerAs;\n        }\n\n        //  Get the actual html of the template.\n        getTemplate(options.template, options.templateUrl)\n          .then(function(template) {\n\n            //  Create a new scope for the modal.\n            var modalScope = $rootScope.$new();\n\n            //  Create the inputs object to the controller - this will include\n            //  the scope, as well as all inputs provided.\n            //  We will also create a deferred that is resolved with a provided\n            //  close function. The controller can then call 'close(result)'.\n            //  The controller can also provide a delay for closing - this is\n            //  helpful if there are closing animations which must finish first.\n            var closeDeferred = $q.defer();\n            var inputs = {\n              $scope: modalScope,\n              close: function(result, delay) {\n                if(delay === undefined || delay === null) delay = 0;\n                window.setTimeout(function() {\n                  //  Resolve the 'close' promise.\n                  closeDeferred.resolve(result);\n                  var modalObj = self.modalLayers.find(function (modalObj) {\n                    return modalObj.modal === modal;\n                  });\n                  self.modalLayers.splice(self.modalLayers.indexOf(modalObj), 1);\n\n                  //  We can now clean up the scope and remove the element from the DOM.\n                  modalScope.$destroy();\n                  modalElement.remove();\n\n                  //  Unless we null out all of these objects we seem to suffer\n                  //  from memory leaks, if anyone can explain why then I'd\n                  //  be very interested to know.\n                  inputs.close = null;\n                  deferred = null;\n                  closeDeferred = null;\n                  modal = null;\n                  inputs = null;\n                  modalElement = null;\n                  modalScope = null;\n                  $rootScope.$applyAsync();\n                }, delay);\n              }\n            };\n\n            //  If we have provided any inputs, pass them to the controller.\n            if(options.inputs) {\n              for(var inputName in options.inputs) {\n                inputs[inputName] = options.inputs[inputName];\n              }\n            }\n\n            //  Parse the modal HTML into a DOM element (in template form).\n            var modalElementTemplate = angular.element(template);\n\n            //  Compile then link the template element, building the actual element.\n            //  Set the $element on the inputs so that it can be injected if required.\n            var linkFn = $compile(modalElementTemplate);\n            var modalElement = linkFn(modalScope);\n            inputs.$element = modalElement;\n\n            //  Create the controller, explicitly specifying the scope to use.\n            var modalController = $controller(controllerName, inputs);\n\n            //  Finally, append the modal to the dom.\n            if (options.appendElement) {\n              // append to custom append element\n              options.appendElement.append(modalElement);\n            } else {\n              // append to body when no custom append element is specified\n              body.append(modalElement);\n            }\n\n            //  We now have a modal object...\n            var modal = {\n              controller: modalController,\n              scope: modalScope,\n              element: modalElement,\n              close: closeDeferred.promise\n            };\n\n            //  ...which is passed to the caller via the promise.\n            self.modalLayers.push({\n              modal: modal,\n              close: inputs.close\n            });\n            deferred.resolve(modal);\n\n          })\n          .then(null, function(error) { // 'catch' doesn't work in IE8.\n            deferred.reject(error);\n          });\n\n        return deferred.promise;\n      };\n\n    }\n\n    return new ModalService();\n  }]);\n\n}());\n"],"sourceRoot":"/source/"}